#import irgen;
#import inner;
#import wrapper;

Val {
    Type_:type_,
    BasicVal?:basic,
    AssignableVal?:assignable,
    ConstVal?:const,
}

BasicVal {
    IRValue:val,
    IRBasicBlock:bb
}

AssignableVal {
    IRValue:addr
}

ConstVal {
    IRValue:val
}

PHINode {
    Type_:type_,
    IRPHIInstruction:ir,
    IRRegister:register
}

Struct_ {
    Str:id,
    Str:name,
    Str:symbol,
    Bool:is_ref,
    [Field]:fields
}

Field {
    Str:name,
    Type_:type_
}

Block {
    IRBasicBlock:entry,
    IRBasicBlock:otherwise,
    IRBasicBlock:end
}

Label {
    IRBasicBlock:block
}

ExternFunc {
    IRFunc:ir_func,
    Type_?:ret_type_,
    [Type_]:args
}

#start irgen [Str:filename] {
    init state [filename];
}

Str#get filename {
    return get state.filename;
}

Str#end irgen {
    Str:result = [build module].stringify;
    clear state;
    return result;
}

Type_ {
    Str:name,
    Z:bits, // -1 indicates null
    [Type_]:generics
}

Bool#[Type_:a] == [Type_:b] {
    return [a] deep equals [b];
}

Bool#[Type_?:a] == [Type_?:b] {
    return [a] deep equals [b];
}

Type_#Null_ {
    return Type_ ["Null", -1, [Type_] []];
}

Type_#Bool_ {
    return Type_ ["Bool", 1, [Type_] []];
}

Type_#Byte_ {
    return Type_ ["Byte", 8, [Type_] []];
}

Type_#W_ {
    return Type_ ["W", 32, [Type_] []];
}

Type_#Z_ {
    return Type_ ["Z", 32, [Type_] []];
}

Type_#Q_ {
    return Type_ ["Q", 64, [Type_] []];
}

Type_#W_ [W:bits] {
    return Type_ ["W", bits, [Type_] []];
}

Type_#L_ {
    return W_ [64];
}

Type_#Z_ [W:bits] {
    return Type_ ["Z", bits, [Type_] []];
}

Type_#Q_ [W:bits] {
    return Type_ ["Q", bits, [Type_] []];
}

Type_#Optional_ [Type_:sub] {
    return Type_ ["Optional", -1, [Type_] [sub]];
}

Type_#Array_ [Type_:sub] {
    return Type_ ["Array", -1, [Type_] [sub]];
}

Type_#Str_ {
    return Array_ [Byte_];
}

// the next three types_ are a small extension to the Epsilon type_ system

Type_#Pointer [Type_:sub] {
    return Type_ ["Pointer", -1, [Type_] [sub]];
}

Type_#FuncPtr [Type_:ret_type_] [[Type_]:arg_types_] {
    return Type_ ["FuncPtr", -1, [[Type_] [ret_type_]] + [arg_types_]];
}

Type_#VoidFuncPtr [[Type_]:arg_types_] {
    return Type_ ["VoidFuncPtr", -1, arg_types_];
}

Type_#T_ [Str:name] {
    return Type_ [name, -1, [Type_] []];
}

Type_#Internal_ {
    return T_ ["Internal"];
}

#[Struct_:struct_].register {
    [get state.structs].append[struct_];
}

Struct_?#[Type_:type_].get_struct {
    for (Struct_:struct_ in get state.structs) {
        if ([struct_.id] equals [type_.name]) {
            return struct_;
        };
    };
    return null;
}

Str#[Type_:type_].stringify {
    if ([type_.generics].len == 0) {
        if (type_.bits == -1) {
            return [type_.name].clone;
        } else {
            return "{}{}" % type_.name % type_.bits;
        };
    };

    Str:generic_txt = "";
    for (Type_:generic in type_.generics) {
        if ([generic_txt].len) {
            [generic_txt].extend[", "];
        };
        [generic_txt].extend[[generic].stringify];
    };

    if (type_.bits == -1) {
        return "{}<{}>" % type_.name % generic_txt;
    } else {
        return "{}{}<{}>" % type_.name % type_.bits % generic_txt;
    };
}

Val#c [Bool:val] {
    return const val [Bool_][make const [val]];
}

Val#c [Byte:val] {
    return const val [Byte_][make const [val]];
}

Val#c [W:val] {
    return const val [W_][make const [val]];
}

Val#c [L:val] {
    abort "Calling 'c' with a value of type L is ambiguous, either use 'c L_' or cast the argument to a W";
}

Val#c L_ [L:val] {
    return const val [L_][make const [val] [64]];
}

Val#c [Z:val] {
    return const val [Z_][make const [val]];
}

Val#c [Q:val] {
    return const val [Q_][make const [val]];
}

Val#c null_ [Type_:type_] {
    return const val [type_][make const null_];
}

Val#c null_ {
    return c null_ [Internal_];
}

Val#c [Z:val] [Type_:type_] {
    if ([type_].is_float) {
        return c [(Q)val] [type_];
    } else {
        return const val [type_][make const [val] [(W)type_.bits]];
    };
}

Val#c [Q:val] [Type_:type_] {
    return const val [type_][make const [val] [(W)type_.bits]];
}

Bool#[Type_:type_].is_signed_int {
    return [type_.name] equals ["Z"];
}

Bool#[Type_:type_].is_unsigned_int {
    Str:name = type_.name;
    return ([name] equals ["Bool"]) || ([name] equals ["Byte"]) || ([name] equals ["W"]);
}

Bool#[Type_:type_].is_int {
    return [type_].is_signed_int || [type_].is_unsigned_int;
}

Bool#[Type_:type_].is_float {
    return [type_.name] equals ["Q"];
}

Bool#[Type_:type_].is_numeric {
    return [type_].is_int || [type_].is_float;
}

Bool#[Type_:type_].is_callable {
    return ([type_.name] equals ["FuncPtr"]) || ([type_.name] equals ["VoidFuncPtr"]);
}

Bool#[Type_:type_].is_nullable {
    return ([type_.name] equals ["Optional"]) || ([type_.name] equals ["Null"]);
}

Bool#[Type_:type_].is_ref {
    if ([type_.name] equals ["Optional"]) {
        return [type_.generics[0]].is_ref;
    };
    if ([type_.name] equals ["Array"]) {
        return true;
    };
    Struct_?:struct_ = [type_].get_struct;
    if ([struct_].is_null) {
        return false;
    };
    return [struct_].unwrap.is_ref;
}

#assert [Type_:type_] is array {
    if ([type_.name] not equals ["Array"]) {
        abort "Expected type_ Array, found {}" % [type_].stringify;
    };
}

#assert [Val:val] is array {
    assert [val.type_] is array;
}

#assert [Type_:type_] is pointer {
    if ([type_.name] not equals ["Pointer"]) {
        abort "Expected type_ Pointer, found {}" % [type_].stringify;
    };
}

#assert [Val:val] is pointer {
    assert [val.type_] is pointer;
}

#assert [Type_:type_] is callable {
    if (![type_].is_callable) {
        abort "Expected callable type_, found {}" % [type_].stringify;
    };
}

#assert [Val:val] is callable {
    assert [val.type_] is callable;
}

Struct_#assert [Type_:val] is struct_ {
    Struct_?:maybe_struct = [val].get_struct;
    if ([maybe_struct].is_null) {
        abort "Expected value with a struct type_, found a value of type_ {}" % [val].stringify;
    };
    return [maybe_struct].unwrap;
}

Struct_#assert [Val:val] is struct_ {
    return assert [val.type_] is struct_;
}

Struct_#assert [Type_:val] is ref struct_ {
    Struct_:struct_ = assert [val] is struct_;
    if (!struct_.is_ref) {
        abort "Expected value with a ref struct type_, found a value of type_ {}" % [val].stringify;
    };
    return struct_;
}

Struct_#assert [Val:val] is ref struct_ {
    return assert [val.type_] is ref struct_;
}

Struct_#assert [Type_:val] is nonref struct_ {
    Struct_:struct_ = assert [val] is struct_;
    if (struct_.is_ref) {
        abort "Expected value with a nonref struct type_, found a value of type_ {}" % [val].stringify;
    };
    return struct_;
}

Struct_#assert [Val:val] is nonref struct_ {
    return assert [val.type_] is nonref struct_;
}

Type_#unwrap nullability [Type_:val] {
    if ([val.name] equals ["Optional"]) {
        return val.generics[0];
    } else {
        return val;
    };
}

Type_#unwrap nullability [Val:val] {
    return unwrap nullability [val.type_];
}

#assert [Val:val] is nullable {
    if (![val.type_].is_nullable) {
        abort "Val of type_ {} is never null" % [val.type_].stringify;
    };
}

#assert [Val:val] is nonnullable {
    if ([val.type_].is_nullable) {
        abort "Val of type_ {} may be null" % [val.type_].stringify;
    };
}

#assert [Val:val] is ref {
    if (![val.type_].is_ref) {
        abort "Val of type_ {} is not a ref type_" % [val.type_].stringify;
    };
}

#assert type_ equality [Val:a], [Val:b] {
    assert type_ equality [a.type_], [b.type_];
}

#assert type_ equality [Type_:a], [Type_:b] {
    if (![a] == [b]) {
        abort "Expected equal types_, found {} and {}" % [a].stringify % [b].stringify;
    };
}

Val#cast [Val:val] to [Type_:type_] {
    return basic val [type_] [cast [[val].get] from [val.type_] to [type_]];
}

Val#bitcast [Val:val] to [Type_:type_] {
    return basic val [type_] [[val].get];
}

Val#[Val:val].truth_value {
    return basic val [Bool_] [compute truth value [val.type_] [[val].get]];
}

Val#[Val:val].untruth_value {
    return basic val [Bool_] [compute untruth value [val.type_] [[val].get]];
}

Val#NOT [Val:val] {
    return basic val [val.type_] [bitwise not [val.type_] [[val].get]];
}

Val#[Val:a] AND [Val:b] {
    assert type_ equality [a], [b];
    return basic val [a.type_] [emit [[[a].get] AND [[b].get] to [[a.type_].ir]]];
}

Val#[Val:a] OR [Val:b] {
    assert type_ equality [a], [b];
    return basic val [a.type_] [emit [[[a].get] OR [[b].get] to [[a.type_].ir]]];
}

Val#[Val:a] XOR [Val:b] {
    assert type_ equality [a], [b];
    return basic val [a.type_] [emit [[[a].get] XOR [[b].get] to [[a.type_].ir]]];
}

Val#[Val:a] + [Val:b] {
    assert type_ equality [a], [b];
    if ([a.type_].is_int) {
        return basic val [a.type_] [emit [[[a].get] add [[b].get] to [[a.type_].ir]]];
    } else {
        return basic val [a.type_] [emit [[[a].get] fadd [[b].get] to [[a.type_].ir]]];
    };
}

Val#[Val:a] - [Val:b] {
    assert type_ equality [a], [b];
    if ([a.type_].is_int) {
        return basic val [a.type_] [emit [[[a].get] sub [[b].get] to [[a.type_].ir]]];
    } else {
        return basic val [a.type_] [emit [[[a].get] fsub [[b].get] to [[a.type_].ir]]];
    };
}

Val#[Val:a] * [Val:b] {
    assert type_ equality [a], [b];
    if ([a.type_].is_int) {
        return basic val [a.type_] [emit [[[a].get] mul [[b].get] to [[a.type_].ir]]];
    } else {
        return basic val [a.type_] [emit [[[a].get] fmul [[b].get] to [[a.type_].ir]]];
    };
}

Val#[Val:a] / [Val:b] {
    assert type_ equality [a], [b];
    if ([a.type_].is_unsigned_int) {
        return basic val [a.type_] [emit [[[a].get] udiv [[b].get] to [[a.type_].ir]]];
    } elif ([a.type_].is_signed_int) {
        return basic val [a.type_] [emit [[[a].get] sdiv [[b].get] to [[a.type_].ir]]];
    } else {
        return basic val [a.type_] [emit [[[a].get] fdiv [[b].get] to [[a.type_].ir]]];
    };
}

Val#[Val:a] % [Val:b] {
    assert type_ equality [a], [b];
    if ([a.type_].is_unsigned_int) {
        return basic val [a.type_] [emit [[[a].get] urem [[b].get] to [[a.type_].ir]]];
    } elif ([a.type_].is_signed_int) {
        return basic val [a.type_] [emit [[[a].get] srem [[b].get] to [[a.type_].ir]]];
    } else {
        return basic val [a.type_] [emit [[[a].get] frem [[b].get] to [[a.type_].ir]]];
    };
}

Val#negate [Val:val] {
    if ([val.type_].is_int) {
        return basic val [val.type_] [emit [[make const [(Z)0]] sub [[val].get] to [[val.type_].ir]]];
    } else {
        return basic val [val.type_] [emit [fneg [[val].get]]];
    };
}

Val#[Val:a] eq [Val:b] {
    return do_Val_cmp[a]["eq"][b];
}

Val#[Val:a] gt [Val:b] {
    return do_Val_cmp[a]["gt"][b];
}

Val#[Val:a] ge [Val:b] {
    return do_Val_cmp[a]["ge"][b];
}

Val#[Val:a] lt [Val:b] {
    return do_Val_cmp[a]["lt"][b];
}

Val#[Val:a] le [Val:b] {
    return do_Val_cmp[a]["le"][b];
}

Val#[Val:a] ne [Val:b] {
    return do_Val_cmp[a]["ne"][b];
}

Val#is_NaN[Val:a] {
    IRValue:a_ir = [a].get;
    return basic val [Bool_] [emit [compare float [a_ir] ["uno"] [a_ir]]];
}

Val#[Val:a] shift left [Val:b] {
    if (![a.type_].is_int || ![b.type_].is_int) {
        abort "Bitshift operations require both types to be an int";
    };
    if (a.type_.bits != b.type_.bits) {
        abort "Both operands in a bitshift must have the same number of bits";
    };

    return basic val [a.type_] [emit [[[a].get] left shift [[b].get] to [[a.type_].ir]]];
}

Val#[Val:a] shift right [Val:b] {
    if (![a.type_].is_int || ![b.type_].is_int) {
        abort "Bitshift operations require both types to be an int";
    };
    if (a.type_.bits != b.type_.bits) {
        abort "Both operands in a bitshift must have the same number of bits";
    };

    if ([a.type_].is_signed_int) {
        return basic val [a.type_] [emit [[[a].get] signed right shift [[b].get] to [[a.type_].ir]]];
    } else {
        return basic val [a.type_] [emit [[[a].get] unsigned right shift [[b].get] to [[a.type_].ir]]];
    };
}

Val#&[Val:v] {
    return basic val [Pointer [v.type_]] [[v.assignable].unwrap.addr];
}

Val#*[Val:val] {
    if ([val.type_.name] not equals ["Pointer"]) {
        abort "Can only directly dereference Pointer type_, not {}" % [val.type_].stringify;
    };
    return assignable val [val.type_.generics[0]] [[val].get];
}

Val#*[Type_:type_][Val:val] {
    return assignable val [type_] [[val].get];
}

Val#load [Val:val] {
    return basic val [val.type_] [[val].get];
}

#[Val:assignable] = [Val:val] {
    if (![val.type_] == [assignable.type_]) {
        abort "Cannot assign value of type_ {} to assignable of type_ {}" % [val.type_].stringify % [assignable.type_].stringify;
    };

    if (assignable.assignable) {
        emit [store [[val].get] in [[assignable.assignable].unwrap.addr]];
    } else {
        abort "Expected assignable";
    };
}

Val#var [Type_:type_] {
    return assignable val [type_] [emit [alloca [[type_].ir]]];
}

Val#var [Type_:type_] [Val:init] {
    Val:var = var [type_];
    [var] = [init];
    return var;
}

Val#var [Val:init] {
    return var [init.type_] [init];
}

ExternFunc#get fn [Str:name] {
    ExternFunc?:fn = get func named [name];
    if ([fn].is_null) {
        abort "Cannot find function with requested name {}" % name;
    };
    return [fn].unwrap;
}

#private accessibility {
    get state.next_fn_private = true;
}

#extern fn [Type_?:ret_type_] [Str:name] [[Type_]:arg_types_] {
    require extern fn [ret_type_] [name] [arg_types_] [false] private: [is next fn private];
}

#extern fn [Type_?:ret_type_] [Str:name] [[Type_]:arg_types_] vargs {
    require extern fn [ret_type_] [name] [arg_types_] [true] private: [is next fn private];
}

#call [ExternFunc:func] [[Val]:args] {
    call [func.ret_type_] [register of func [func.ir_func]] [func.args] [args];
}

#call [Val:func] [[Val]:args] {
    assert [func] is callable;
    [Type_]:arg_types_ = func.type_.generics;
    Type_?:ret_type_ = null;
    if ([func.type_.name] equals ["FuncPtr"]) {
        arg_types_ = [arg_types_].clone;
        ret_type_ = [arg_types_].pop[0];
    };
    IRRegister?:maybe_register = [func].get.register;
    if ([maybe_register].is_null) {
        abort "Can't call a constant as a a function pointer";
    };
    call [ret_type_] [[maybe_register].unwrap] [arg_types_] [args];
}

#extern fn [Type_?:ret_type_] [Str:name] [[Type_]:arg_types_] [[Val]:provided_args] {
    if ([arg_types_].len != [provided_args].len) {
        abort "The number of arguments and the number of argument types_ must match (got {} and {} for {})"
            % [provided_args].len % [arg_types_].len % name;
    };
    ExternFunc:func = require extern fn [ret_type_] [name] [arg_types_] [false] private: [is next fn private];
    call [func] [provided_args];
}

#extern fn [Type_?:ret_type_] [Str:name] [[Type_]:arg_types_] vargs [[Val]:provided_args] {
    ExternFunc:func = require extern fn [ret_type_] [name] [arg_types_] [true] private: [is next fn private];
    call [func] [provided_args];
}

Bool#fn [Type_?:ret_type_] [Str:name] [[Type_]:arg_types_] {
    Bool:is_private = is next fn private;
    Func_?:defined_fn = defined fn [ret_type_] [name] [arg_types_];
    if (defined_fn) {
        get state.last_defined_func = [defined_fn].unwrap.base;
        return false;
    } else {
        Func_:new_fn = new fn [ret_type_] [name] [arg_types_] private: [is_private];
        get state.last_defined_func = new_fn.base;
        add fn [new_fn];
        return true;
    };
}

Bool#fn [Type_?:ret_type_] [Str:name] [[Type_]:arg_types_] [[Val]:provided_args] {
    if ([arg_types_].len != [provided_args].len) {
        abort "The number of arguments and the number of argument types_ must match (got {} and {} for {})"
            % [provided_args].len % [arg_types_].len % name;
    };
    Bool:is_private = is next fn private;
    Func_?:defined_fn = defined fn [ret_type_] [name] [arg_types_];
    if (defined_fn) {
        call [[defined_fn].unwrap.base] [provided_args];
        get state.last_defined_func = [defined_fn].unwrap.base;
        return false;
    } else {
        Func_:new_fn = new fn [ret_type_] [name] [arg_types_] private: [is_private];
        call [new_fn.base] [provided_args];
        get state.last_defined_func = new_fn.base;
        add fn [new_fn];
        return true;
    };
}

Bool#specialized fn [Type_?:ret_type_] [Str:name] [[Val]:args] {
    [Type_]:arg_types_ = [Type_] [];
    for (Val:arg in args) {
        [arg_types_].append[arg.type_];
    };
    Str:full_name = [name].clone;
    for (Type_:arg_type_ in arg_types_) {
        [full_name].append['_'];
        [full_name].extend[[arg_type_].stringify];
    };
    private accessibility;
    return fn [ret_type_] [full_name] [arg_types_] [args];
}

Bool#specialized fn [Type_?:ret_type_] [Str:name] [[Type_]:arg_types_] {
    Str:full_name = [name].clone;
    for (Type_:arg_type_ in arg_types_) {
        [full_name].append['_'];
        [full_name].extend[[arg_type_].stringify];
    };
    private accessibility;
    return fn [ret_type_] [full_name] [arg_types_];
}

#ret void {
    emit [ret void instruction];
}

#ret [Val:val] {
    emit [ret [[val].get]];
}

#mark as unreachable {
    emit [unreachable instruction];
}

#end fn {
    require basic block termination;
    [Func_]:func_stack = get state.func_stack;
    [func_stack].pop_end;
}

Val#func ret {
    Val?:ret = get active func.last_ret_val;
    if ([ret].is_null) {
        abort "The current function has not called another function";
    };
    return [ret].unwrap;
}

Type_#[ExternFunc:func].ptr_type_ {
    if (func.ir_func.has_vargs) {
        abort "Pointers to functions with vargs currently can't be represented in the EEWriter types system";
    };
    if (func.ret_type_) {
        return FuncPtr [[func.ret_type_].unwrap] [func.args];
    } else {
        return VoidFuncPtr [func.args];
    };
}

Val#func ptr {
    ExternFunc?:func = get state.last_defined_func;
    if ([func].is_null) {
        abort "A function must be defined or required before a function pointer can be created";
    };
    return [[func].unwrap].func_ptr;
}

Val#[ExternFunc:func].func_ptr {
    return const val [[func].ptr_type_] [[func.ir_func].make_ptr];
}

Val#func arg [L:i] {
    Type_:type_ = get active func.base.args[i];
    return basic val [type_] [make_val [IRRegister [false, "arg{}" % i, [type_].ir]]];
}

Val#alloca [Val:count] [Type_:type_] {
    return assignable val [type_] [emit [alloca [[count].get] [[type_].ir]]];
}

Block#current block {
    [Block]:block_stack = get active func.block_stack;
    return [block_stack].at[-1];
}

Bool#is block terminated {
    return current bb.is_terminated;
}

#break_ [Block:block] {
    emit [branch to [block.otherwise]];
}

#continue_ [Block:block] {
    emit [branch to [block.entry]];
}

#end block {
    Block:block = pop from block stack;
    emit [branch to [block.end]] unless terminated;
    set current bb [block.otherwise];
}

Label#new label {
    return Label [new bb];
}

#[Label:label]: {
    emit [branch to [label.block]] unless terminated;
    set current bb [label.block];
}

Label#new label: {
    IRBasicBlock:bb = new bb;
    emit [branch to [bb]] unless terminated;
    set current bb [bb];
    return Label [bb];
}

#goto_ [Label:label] {
    emit [branch to [label.block]] unless terminated;
}

#goto_ [Val:cond] ? [Label:if_true] : [Label:if_false] {
    IRValue:cond_bool = compute truth value [cond.type_] [[cond].get];
    emit [branch to [if_true.block] if_ [cond_bool] else_ [if_false.block]] unless terminated;
}

#switch_ on [Val:val] to [[Val]:targets] [[Label]:labels] otherwise [Label:otherwise] {
    [IRConstant]:const_targets = [IRConstant] [];
    for (Val:target in targets) {
        [const_targets].append[get_const_from_val[target]];
    };
    [IRBasicBlock]:blocks = [IRBasicBlock] [];
    for (Label:label in labels) {
        [blocks].append[label.block];
    };
    emit [switch_ on [[val].get] to [const_targets] [blocks] otherwise [otherwise.block]];
}

#if_ [Val:cond] {
    IRBasicBlock:entry = new bb;
    IRBasicBlock:otherwise = new bb;
    IRValue:cond_bool = compute truth value [cond.type_] [[cond].get];
    emit [branch to [entry] if_ [cond_bool] else_ [otherwise]];
    add block [Block [entry, otherwise, otherwise]] to stack;
    set current bb [entry];
}

#else_ {
    IRBasicBlock:otherwise = pop from block stack.otherwise;
    IRBasicBlock:end = new bb;
    add block [Block [otherwise, end, end]] to stack;
    emit [branch to [end]] unless terminated;
    set current bb [otherwise];
}

#while_ [Val:cond] from [Label:label] {
    IRBasicBlock:entry = label.block;
    IRBasicBlock:body = new bb;
    IRBasicBlock:otherwise = new bb;
    IRValue:cond_bool = compute truth value [cond.type_] [[cond].get];
    emit [branch to [body] if_ [cond_bool] else_ [otherwise]];
    add block [Block [entry, otherwise, entry]] to stack;
    set current bb [body];
}

#start block [Block:block] {
    require basic block termination;
    add block [block] to stack;
    set current bb [block.entry];
}

Block#create block with entry [Label:entry], otherwise [Label:otherwise], ending with [Label:end] {
    return Block [entry.block, otherwise.block, end.block];
}

PHINode#new PHI [Type_:type_] {
    return PHINode [type_, IRPHIInstruction [[IRValue] [], [W] []], new register [[type_].ir]];
}

#[PHINode:phi].add_incoming[Val:val] {
    if (![val.type_] == [phi.type_]) {
        abort "Incorrect type_ for PHI operand: expected {}, found {}" % [phi.type_].stringify % [val.type_].stringify;
    };
    val = load [val];
    if (val.basic) {
        BasicVal:basic = [val.basic].unwrap;
        [phi.ir.vals].append[basic.val];
        [phi.ir.block_ids].append[basic.bb.id];
    } else {
        abort "Expected BasicVal";
    };
}

Val#[PHINode:phi].place_here {
    emit [wrap PHI [phi.register] [phi.ir]];
    return [phi].val;
}

Val#[PHINode:phi].val {
    return basic val [phi.type_] [make_val [phi.register]];
}

// always evaluates both operands
Val#[Val:cond] ? [Val:if_true] : [Val:if_false] {
    assert type_ equality [if_true], [if_false];
    IRValue:ir_cond = compute truth value [cond.type_] [[cond].get];
    return basic val [if_true.type_] [emit [
        select [[if_true.type_].ir] [[if_true].get] if_ [ir_cond] else_ [[if_false].get]
    ]];
}

Val#[Val:ptr] shifted by [Val:offset] {
    IRType:pointee = [ptr.type_].pointee;
    IRValuedInstruction:GEP = GEP [pointee] [[ptr].get] [[IRValue] [[offset].get]];
    return basic val [ptr.type_] [emit [GEP]];
}

Val#sizeof [Type_:type_] {
    IRValue:ptr = [[c null_ [Pointer [type_]]] shifted by [c L_[1]]].get;
    return basic val [L_] [emit [ptr [ptr] to int [int type [64]]]];
}

Val#sizeof pointee [Type_:type_] {
    IRValue:ptr = [[c null_ [type_]] shifted by [c L_[1]]].get;
    return basic val [L_] [emit [ptr [ptr] to int [int type [64]]]];
}

Val#sizeof elem [Type_:type_] {
    assert [type_] is array;
    return sizeof [type_.generics[0]];
}

Val#malloc [Val:bytes] {
    extern fn [Internal_] ["epsl_malloc"] [[Type_] [L_]]
        [[Val] [cast [bytes] to [L_]]];
    return func ret;
}

Val#malloc [Type_:type_] {
    return cast [malloc [sizeof [type_]]] to [Pointer [type_]];
}

Val#malloc [Val:count] [Type_:type_] {
    return cast [malloc [[sizeof [type_]] * [cast [count] to [L_]]]] to [Pointer [type_]];
}

Val#malloc pointee [Type_:type_] {
    return cast [malloc [sizeof pointee [type_]]] to [type_];
}

Val#malloc pointee [Val:count] [Type_:type_] {
    return cast [malloc [[sizeof pointee [type_]] * [cast [count] to [L_]]]] to [type_];
}

Val#realloc [Val:val] to [Val:bytes] bytes {
    extern fn [Internal_] ["epsl_realloc"] [[Type_] [Internal_, L_]]
        [[Val] [val, cast [bytes] to [L_]]];
    return func ret;
}

Val#realloc [Val:val] to [Val:count] elements {
    assert [val] is pointer;
    Val:bytes = [sizeof pointee [val.type_]] * [cast [count] to [L_]];
    return cast [realloc [cast [val] to [Internal_]] to [bytes] bytes] to [val.type_];
}

#free [Val:val] {
    extern fn [null] ["free"] [[Type_] [Internal_]] [[Val] [cast [val] to [Internal_]]];
}

#memcpy [Val:count] [Val:v1] to [Val:v2] {
    extern fn [Internal_] ["epsl_memcpy"] [[Type_] [Internal_, Internal_, L_]] [[Val] [
        cast [v2] to [Internal_], cast [v1] to [Internal_],
        [sizeof pointee [v1.type_]] * [cast [count] to [L_]]
    ]];
}

#memcpy [Val:v1] to [Val:v2] {
    extern fn [Internal_] ["epsl_memcpy"] [[Type_] [Internal_, Internal_, L_]] [[Val] [
        cast [v2] to [Internal_], cast [v1] to [Internal_], sizeof pointee [v1.type_]
    ]];
}

#assume [Val:val] {
    if (![val.type_] == [Bool_]) {
        abort "Can only assume that a boolean is true, not a {}" % [val.type_].stringify;
    };
    extern fn [null] ["llvm.assume"] [[Type_] [Bool_]] [[Val] [val]];
}

// returns the val with the expectation attached
Val#expect [Val:val] to be [Bool:truth_value] {
    if (![val.type_] == [Bool_]) {
        abort "Can only provide an expectation of a boolean's value, found a {}" % [val.type_].stringify;
    };
    extern fn [Bool_] ["llvm.expect.i1"] [[Type_] [Bool_, Bool_]] [[Val] [val, c [truth_value]]];
    return func ret;
}

Val#[Val:arr].capacity {
    assert [arr] is array;
    return *[access field [1] of [arr] as [L_]];
}

Val#[Val:arr].length {
    assert [arr] is array;
    return *[access field [2] of [arr] as [L_]];
}

Val#[Val:arr].content {
    assert [arr] is array;
    return *[access field [3] of [arr] as [Pointer [arr.type_.generics[0]]]];
}

Val#[Val:val].idx[Val:idx] {
    if ([val.type_.name] equals ["Array"]) {
        return [[val].content].idx[idx];
    } elif ([val.type_.name] equals ["Pointer"]) {
        return *[[val] shifted by [idx]];
    } else {
        abort "Cannot index into value of type_ {}" % [val.type_].stringify;
    };
}

Val#[Val:val].[L:field] {
    Struct_:struct_ = assert [val] is ref struct_;
    // +1 because of the ref_counter field
    return *[access field [field+1] of [val] as [struct_.fields[field].type_]];
}

Val#[Val:val].[Str:field] {
    Struct_:struct_ = assert [val] is ref struct_;
    L:field_idx = index of field [field] in [struct_];
    // +1 because of the ref_counter field
    return *[access field [field_idx+1] of [val] as [struct_.fields[field_idx].type_]];
}

Val#get field [Str:field] of [Val:val] {
    Struct_:struct_ = assert [val] is nonref struct_;
    L:field_idx = index of field [field] in [struct_];
    Type_:field_type_ = struct_.fields[field_idx].type_;
    return basic val [field_type_] [emit [
        extract value [[val].get] [[W] [field_idx]] [[field_type_].ir]
    ]];
}

Val#with field [Str:field] of [Val:val] as [Val:new_] {
    Struct_:struct_ = assert [val] is nonref struct_;
    L:field_idx = index of field [field] in [struct_];
    Type_:field_type_ = struct_.fields[field_idx].type_;
    if (![new_.type_] == [field_type_]) {
        abort "Field {} has type_ {}, cannot insert value of type_ {}" % field % [field_type_].stringify % [new_.type_].stringify;
    };
    return basic val [field_type_] [emit [
        insert value [[new_].get] [[val].get] [[W] [field_idx]]
    ]];
}

Val#make global [Type_:type_] [Str?:name] [Val?:init] {
    IRConstant?:const_init = null;
    if (init) {
        const_init = get_const_from_val[[init].unwrap];
    };
    IRValue:ir_ptr = make_global type: [[type_].ir] name: [name]
        basic_init: [const_init] str_init: [null] is_extern: [false]
        is_const: [false];
    return assignable val [type_] [ir_ptr];
}

Val#make ptr to global [Type_:type_] [Str?:name] [Val?:init] {
    IRConstant?:const_init = null;
    if (init) {
        const_init = get_const_from_val[[init].unwrap];
    };
    IRValue:ir_ptr = make_global type: [[type_].ir] name: [name]
        basic_init: [const_init] str_init: [null] is_extern: [false] is_const: [false];
    return const val [Pointer [type_]] [ir_ptr];
}

Val#extern global [Type_:type_] [Str:name] {
    return assignable val [type_] [
        make_global type: [[type_].ir] name: [name] basic_init: [null]
            str_init: [null] is_extern: [true] is_const: [false]
    ];
}

Val#make const [Type_:type_] [Str?:name] [Val:init] {
    return assignable val [type_] [
        make_global type: [[type_].ir] name: [name]
            basic_init: [get_const_from_val[init]] str_init: [null]
            is_extern: [false] is_const: [true]
    ];
}

Val#const str [Str:str] {
    IRType:type = array type [[str].len]x[int type [8]];
    return const val [Pointer [Byte_]] [
        make_global type: [type] name: [null] basic_init: [null] str_init: [str]
            is_extern: [false] is_const: [true]
    ];
}

Val#mut str [Str:str] with [W:extra_cap] extra capacity {
    Val:result = malloc [c L_ [[str].len + extra_cap]] [Byte_];
    memcpy [c L_ [[str].len]] [const str [str]] to [result];
    return result;
}

Val#mut str [Str:str] {
    return mut str [str] with [0] extra capacity;
}

#add error frame [Str:frame] {
    // *++epsl_error_stack_top = frame;
    Val:error_stack_top = get error stack top;
    Val:new_top = [error_stack_top] shifted by [c L_ [1]];
    [*[new_top]] = [const str [frame]];
    [error_stack_top] = [new_top];
}

#remove error frame {
    Val:error_stack_top = get error stack top;
    Val:new_top = [error_stack_top] shifted by [c [-1]];
    [error_stack_top] = [new_top];
}

Val#new array [Type_:type_] [[Val]:vals] with capacity [L:capacity] {
    if ([type_.name] not equals ["Array"]) {
        abort "Expected Array type_, found {}" % [type_].stringify;
    };

    Val:result = malloc pointee [type_];
    [result].init_ref;

    if (capacity < [vals].len) {
        capacity = [vals].len;
    };
    if (capacity < 0) {
        capacity = 1;
    };
    [[result].capacity] = [c L_ [capacity]];

    [[result].length] = [c L_ [[vals].len]];

    Val:content = malloc [c L_ [capacity]] [type_.generics[0]];
    for (L:i enumerating vals) {
        [[content].idx[c L_ [i]]] = [vals[i]];
    };
    [[result].content] = [content];

    return result;
}

Val#new array [Type_:type_] [[Val]:vals] {
    return new array [type_] [vals] with capacity [0];
}

Val#new ref struct_ [Type_:type_] [[Val]:fields] {
    Struct_?:maybe_struct = [type_].get_struct;
    if ([maybe_struct].is_null) {
        abort "Expected struct type_, found {}" % type_.name;
    };

    Struct_:struct_ = [maybe_struct].unwrap;
    if (!struct_.is_ref) {
        abort "Expected ref struct type_, found {}" % struct_.id;
    };

    Val:result = malloc pointee [type_];
    [result].init_ref;

    for (L:i enumerating fields) {
        Val:field_val = fields[i];
        Field:struct_field = struct_.fields[i];
        if (![field_val.type_] == [struct_field.type_]) {
            abort "Expected value of type_ {} for field {}, found value of type_ {}" % [struct_field.type_].stringify % struct_field.name % [field_val.type_].stringify;
        };
        [[result].[i]] = [field_val];
    };

    return result;
}

#printf [Str:template] [[Val]:vals] {
    extern fn [Z_] ["epsl_printf"] [[Type_] [Pointer [Byte_]]] vargs
        [[[Val] [const str [template]]] + [vals]];
}

Val#[Val:val] == null_ {
    assert [val] is nullable;
    return basic val [Bool_] [emit [compare int [[val].get] ["eq"] [make const null_]]];
}

Val#[Val:val] != null_ {
    assert [val] is nullable;
    return basic val [Bool_] [emit [compare int [[val].get] ["ne"] [make const null_]]];
}

Val#[Val:val].ref {
    assert [val] is nonnullable;
    assert [val] is ref;
    return *[access field [0] of [val] as [L_]];
}

#[Val:val].init_ref {
    [[val].ref] = [c L_ [0]];
}

#[Val:val].incr_ref {
    if (![val.type_].is_ref) {
        return;
    };
    val = load [val];
    if ([val.type_].is_nullable) {
        if_ [[val] != null_];
    };
    Val:rc = *[bitcast [val] to [Pointer [L_]]];
    [rc] = [[rc] + [c L_ [1]]];
    if ([val.type_].is_nullable) {
        end block;
    };
}

#[Val:val].checkless_decr_ref {
    if (![val.type_].is_ref) {
        return;
    };
    val = load [val];
    if ([val.type_].is_nullable) {
        if_ [[val] != null_];
    };
    Val:rc = *[bitcast [val] to [Pointer [L_]]];
    [rc] = [[rc] - [c L_ [1]]];
    if ([val.type_].is_nullable) {
        end block;
    };
}

#[Val:val].decr_ref {
    if (![val.type_].is_ref) {
        return;
    };
    val = load [val];
    if ([val.type_].is_nullable) {
        if_ [[val] != null_];
    };
    Val:rc = *[bitcast [val] to [Pointer [L_]]];
    Val:new_rc = [rc] - [c L_ [1]];
    [rc] = [new_rc];
    [bitcast [val] to [unwrap nullability [val]]]._nonnull_check_ref[new_rc];
    if ([val.type_].is_nullable) {
        end block;
    };
}

#[Val:val].check_ref {
    if (![val.type_].is_ref) {
        return;
    };
    val = load [val];
    if ([val.type_].is_nullable) {
        if_ [[val] != null_];
    };
    Val:rc = *[bitcast [val] to [Pointer [L_]]];
    [bitcast [val] to [unwrap nullability [val]]]._nonnull_check_ref[rc];
    if ([val.type_].is_nullable) {
        end block;
    };
}
