%import irgen;
%import inner;
%import wrapper;

Val {
    Type_:type_,
    BasicVal?:basic,
    AssignableVal?:assignable,
    ConstVal?:const,
}

BasicVal {
    IRValue:val,
    IRBasicBlock:bb
}

AssignableVal {
    IRValue:addr
}

ConstVal {
    IRValue:val
}

PHINode {
    Type_:type_,
    IRPHIInstruction:ir
}

Struct_ {
    Str:id,
    L:id_num,
    Str:name,
    Str:symbol,
    Str?:destructor,
    Bool:has_global_free_fn,
    Bool:is_super,
    [L]:extendee_ids,
    Bool:is_ref,
    [Field]:fields
}

Field {
    Str:name,
    Type_:type_
}

Block {
    IRBasicBlock:entry,
    IRBasicBlock:otherwise,
    IRBasicBlock:end
}

Label {
    IRBasicBlock:block
}

ExternFunc {
    IRFunc:ir_func,
    Type_:ret_type_,
    [Type_]:args
}

#start irgen [Str:filename] {
    init state [filename];
}

Str#get filename {
    return get state.filename;
}

Str#end irgen {
    Str:result = [build module].stringify;
    clear state;
    return result;
}

Type_ {
    Str:name,
    Z:bits, // -1 indicates null
    [Type_]:generics
}

Bool#[Type_:a] == [Type_:b] {
    return [a] deep equals [b];
}

Type_#T_ [Str:name] {
    return Type_ [name, -1, [Type_] []];
}

Type_#Internal_ {
    return T_ ["Internal"];
}

Type_#Null_ {
    return T_ ["Null"];
}

Type_#Bool_ {
    return Type_ ["Bool", 1, [Type_] []];
}

Type_#Byte_ {
    return Type_ ["Byte", 8, [Type_] []];
}

Type_#W_ {
    return Type_ ["W", 32, [Type_] []];
}

Type_#Z_ {
    return Type_ ["Z", 32, [Type_] []];
}

Type_#R_ {
    return Type_ ["R", 64, [Type_] []];
}

Type_#W_ [W:bits] {
    return Type_ ["W", bits, [Type_] []];
}

Type_#L_ {
    return W_ [64];
}

Type_#Z_ [W:bits] {
    return Type_ ["Z", bits, [Type_] []];
}

Type_#R_ [W:bits] {
    return Type_ ["R", bits, [Type_] []];
}

Type_#Optional_ [Type_:sub] {
    return Type_ ["Optional", -1, [Type_] [sub]];
}

Type_#Array_ [Type_:sub] {
    return Type_ ["Array", -1, [Type_] [sub]];
}

Type_#Str_ {
    return Array_ [Byte_];
}

Type_#Poly_ [Type_:sub] {
    return Type_ ["Poly", -1, [Type_] [sub]];
}

// the next five types_ are a small extension to the Epsilon type_ system

Type_#Pointer [Type_:sub] {
    return Type_ ["#Pointer", -1, [Type_] [sub]];
}

Type_#FuncPtr [Type_:ret_type_] [[Type_]:arg_types_] {
    return Type_ ["#FuncPtr", -1, [[Type_] [ret_type_]] + [arg_types_]];
}

Type_#VTable [Type_:generic] {
    return Type_ ["#VTable", -1, [Type_] [generic]];
}

Type_#StructBase {
    return T_ ["#StructBase"];
}

#[Struct_:struct_].register {
    [get state.structs].append[struct_];
}

Struct_?#get struct_ by id [Str:id] {
    for (Struct_:struct_ in get state.structs) {
        if ([struct_.id] equals [id]) {
            return struct_;
        };
    };
    return null;
}

Struct_?#[Type_:type_].get_struct {
    return get struct_ by id [type_.name];
}

Bool#[Struct_:a] extends [Struct_:b] {
   return ![[a.extendee_ids].index_of[b.id_num]].is_null;
}

Str#[Type_:type_].stringify {
    if ([type_.generics].len == 0) {
        if (type_.bits == -1) {
            return [type_.name].clone;
        } else {
            return "{}{}" % type_.name % type_.bits;
        };
    };

    Str:generic_txt = [""].clone;
    for (Type_:generic in type_.generics) {
        if ([generic_txt].len) {
            [generic_txt].extend[", "];
        };
        [generic_txt].extend[[generic].stringify];
    };

    if (type_.bits == -1) {
        return "{}<{}>" % type_.name % generic_txt;
    } else {
        return "{}{}<{}>" % type_.name % type_.bits % generic_txt;
    };
}

Val#c [Bool:val] {
    return const val [Bool_][make const [val]];
}

Val#c [Byte:val] {
    return const val [Byte_][make const [val]];
}

Val#c [W:val] {
    return const val [W_][make const [val]];
}

Val#c [L:val] {
    abort ["Calling 'c' with a value of type L is ambiguous, either use 'c L_' or cast the argument to a W"];
}

Val#c L_ [L:val] {
    return const val [L_][make const [val] [64]];
}

Val#c [Z:val] {
    return const val [Z_][make const [(W)val]];
}

Val#c [R:val] {
    return const val [R_][make const [val]];
}

Val#c null_ [Type_:type_] {
    if ([type_.name] equals ["Optional"]) {
        Type_:generic = type_.generics[0];
        if ([generic].is_nonnull_ptr) {
            return const val [type_][make const null_ ptr];
        } elif ([generic].is_poly) {
            $IRConstant:null_ptr = get_const_from_val[make const null_ ptr];
            return const val [type_][make const [[type_].ir] [[$IRConstant] [
                null_ptr, null_ptr
            ]]];
        } else {
            return const val [type_] [make const [[type_].ir] [[$IRConstant] [
                get_const_from_val[make const [false]],
                get_const_from_val[make const [[generic].ir] poison]
            ]]];
        };
    } elif ([type_].is_ptr) {
        return const val [type_][make const null_ ptr];
    } elif ([type_.name] equals ["Null"]) {
        return const val [type_][make const [false]];
    };
    abort ["Can't produce null of type_ {}" % [type_].stringify];
}

Val#c null_ {
    return c null_ [Internal_];
}

Val#c [Z:val] [Type_:type_] {
    if ([type_].is_float) {
        return c [(R)val] [type_];
    } else {
        return const val [type_][make const [(L)val] [(W)type_.bits]];
    };
}

Val#c [R:val] [Type_:type_] {
    return const val [type_][make const [val] [(W)type_.bits]];
}

Bool#[Type_:type_].is_signed_int {
    return [type_.name] equals ["Z"];
}

Bool#[Type_:type_].is_unsigned_int {
    Str:name = type_.name;
    return ([name] equals ["Bool"]) || ([name] equals ["Byte"]) || ([name] equals ["W"]);
}

Bool#[Type_:type_].is_int {
    return [type_].is_signed_int || [type_].is_unsigned_int;
}

Bool#[Type_:type_].is_float {
    return [type_.name] equals ["R"];
}

Bool#[Type_:type_].is_numeric {
    return [type_].is_int || [type_].is_float;
}

Bool#[Type_:type_].is_callable {
    return [type_.name] equals ["#FuncPtr"];
}

Bool#[Type_:type_].is_nullable {
    return ([type_.name] equals ["Optional"]) || ([type_.name] equals ["Null"]);
}

Bool#[Type_:type_].is_poly {
    return ([type_.name] equals ["Poly"]) || ([type_.name] equals ["Struct"]);
}

Bool#[Type_:type_].is_ref {
    if ([type_.name] equals ["Optional"]) {
        return [type_.generics[0]].is_ref;
    };
    if (([type_.name] equals ["Array"]) || ([type_].is_poly)
        || ([type_.name] equals ["#StructBase"])) {
        return true;
    };
    Struct_?:struct_ = [type_].get_struct;
    if ([struct_].is_null) {
        return false;
    };
    return [struct_].unwrap.is_ref;
}

#assert [Type_:type_] is array {
    if ([type_.name] not equals ["Array"]) {
        abort ["Expected type_ Array, found {}" % [type_].stringify];
    };
}

#assert [Val:val] is array {
    assert [val.type_] is array;
}

#assert [Type_:type_] is poly {
    if (![type_].is_poly) {
        abort ["Expected type_ Poly, found {}" % [type_].stringify];
    };
}

#assert [Val:val] is poly {
    assert [val.type_] is poly;
}

#assert [Type_:type_] is vtable {
    if ([type_.name] not equals ["#VTable"]) {
        abort ["Expected type_ VTable, found {}" % [type_].stringify];
    };
}

#assert [Val:val] is vtable {
    assert [val.type_] is vtable;
}

#assert [Type_:type_] is pointer {
    if ([type_.name] not equals ["#Pointer"]) {
        abort ["Expected type_ Pointer, found {}" % [type_].stringify];
    };
}

#assert [Val:val] is pointer {
    assert [val.type_] is pointer;
}

#assert [Type_:type_] is callable {
    if (![type_].is_callable) {
        abort ["Expected callable type_, found {}" % [type_].stringify];
    };
}

#assert [Val:val] is callable {
    assert [val.type_] is callable;
}

Struct_#assert [Type_:val] is struct_ {
    Struct_?:maybe_struct = [val].get_struct;
    if ([maybe_struct].is_null) {
        abort ["Expected value with a struct type_, found a value of type_ {}" % [val].stringify];
    };
    return [maybe_struct].unwrap;
}

Struct_#assert [Val:val] is struct_ {
    return assert [val.type_] is struct_;
}

Struct_#assert [Type_:val] is ref struct_ {
    Struct_:struct_ = assert [val] is struct_;
    if (!struct_.is_ref) {
        abort ["Expected value with a ref struct type_, found a value of type_ {}" % [val].stringify];
    };
    return struct_;
}

Struct_#assert [Val:val] is ref struct_ {
    return assert [val.type_] is ref struct_;
}

Struct_#assert [Type_:val] is nonref struct_ {
    Struct_:struct_ = assert [val] is struct_;
    if (struct_.is_ref) {
        abort ["Expected value with a nonref struct type_, found a value of type_ {}" % [val].stringify];
    };
    return struct_;
}

Struct_#assert [Val:val] is nonref struct_ {
    return assert [val.type_] is nonref struct_;
}

Type_#unwrap nullability [Type_:type_] {
    if ([type_.name] equals ["Optional"]) {
        return type_.generics[0];
    } else {
        return type_;
    };
}

Type_#deep unwrap nullability [Type_:type_] {
    while ([type_.name] equals ["Optional"]) {
        type_ = type_.generics[0];
    };
    return type_;
}

Val#unwrap nullability [Val:val] {
    return cast [val] to [unwrap nullability [val.type_]];
}

Val#deep unwrap nullability [Val:val] {
    while ([val.type_.name] equals ["Optional"]) {
        val = unwrap nullability [val];
    };
    return val;
}

#assert [Val:val] is nullable {
    if (![val.type_].is_nullable) {
        abort ["Val of type_ {} is never null" % [val.type_].stringify];
    };
}

#assert [Val:val] is nonnullable {
    if ([val.type_].is_nullable) {
        abort ["Val of type_ {} may be null" % [val.type_].stringify];
    };
}

#assert [Type_:type_] is optional {
    if ([type_.name] not equals ["Optional"]) {
        abort ["Type_ {} is not an Optional" % [type_].stringify];
    };
}

#assert [Val:val] is optional {
    assert [val.type_] is optional;
}

#assert [Val:val] is ref {
    if (![val.type_].is_ref) {
        abort ["Val of type_ {} is not a ref type_" % [val.type_].stringify];
    };
}

Type_#assert type_ equality [Val:a], [Val:b] {
    assert type_ equality [a.type_], [b.type_];
    return a.type_;
}

#assert type_ equality [Type_:a], [Type_:b] {
    if (![a] == [b]) {
        abort ["Expected equal types_, found {} and {}" % [a].stringify % [b].stringify];
    };
}

Val#cast [Val:val] to [Type_:type_] {
    return basic val [type_] [cast [[val].get] from [val.type_] to [type_]];
}

Val#bitcast [Val:val] to [Type_:type_] {
    return basic val [type_] [[val].get];
}

Val#[Val:val].truth_value {
    return basic val [Bool_] [compute truth value [val.type_] [[val].get]];
}

Val#[Val:val].untruth_value {
    return basic val [Bool_] [compute untruth value [val.type_] [[val].get]];
}

Val#NOT [Val:val] {
    return basic val [val.type_] [bitwise not [val.type_] [[val].get]];
}

Val#[Val:a] AND [Val:b] {
    Type_:type_ = assert type_ equality [a], [b];
    return basic val [type_] [emit [IRANDInstruction [
        new register [type_], [Str] [], [a].get, [b].get
    ]]];
}

Val#[Val:a] OR [Val:b] {
    Type_:type_ = assert type_ equality [a], [b];
    return basic val [type_] [emit [IRORInstruction [
        new register [type_], [Str] [], [a].get, [b].get
    ]]];
}

Val#[Val:a] XOR [Val:b] {
    Type_:type_ = assert type_ equality [a], [b];
    return basic val [type_] [emit [IRXORInstruction [
        new register [type_], [Str] [], [a].get, [b].get
    ]]];
}

Val#[Val:a] + [Val:b] bound: [Bool:bound] {
    Type_:type_ = assert type_ equality [a], [b];
    if ([type_].is_int) {
        return basic val [type_] [emit [IRAdditionInstruction [
            new register [type_], get instr flags [type_] bound: [bound], [a].get, [b].get
        ]]];
    } else {
        return basic val [type_] [emit [IRFloatAdditionInstruction [
            new register [type_], get instr flags [type_] bound: [bound], [a].get, [b].get
        ]]];
    };
}

Val#[Val:a] - [Val:b] bound: [Bool:bound] {
    Type_:type_ = assert type_ equality [a], [b];
    if ([type_].is_int) {
        return basic val [type_] [emit [IRSubtractionInstruction [
            new register [type_], get instr flags [type_] bound: [bound], [a].get, [b].get
        ]]];
    } else {
        return basic val [type_] [emit [IRFloatSubtractionInstruction [
            new register [type_], get instr flags [type_] bound: [bound], [a].get, [b].get
        ]]];
    };
}

Val#[Val:a] * [Val:b] bound: [Bool:bound] {
    Type_:type_ = assert type_ equality [a], [b];
    if ([type_].is_int) {
        return basic val [type_] [emit [IRMultiplicationInstruction [
            new register [type_], get instr flags [type_] bound: [bound], [a].get, [b].get
        ]]];
    } else {
        return basic val [type_] [emit [IRFloatMultiplicationInstruction [
            new register [type_], get instr flags [type_] bound: [bound], [a].get, [b].get
        ]]];
    };
}

Val#[Val:a] / [Val:b] {
    Type_:type_ = assert type_ equality [a], [b];
    if ([type_].is_unsigned_int) {
        return basic val [type_] [emit [IRUnsignedDivisionInstruction [
            new register [type_], [Str] [], [a].get, [b].get
        ]]];
    } elif ([type_].is_signed_int) {
        return basic val [type_] [emit [IRSignedDivisionInstruction [
            new register [type_], [Str] [], [a].get, [b].get
        ]]];
    } else {
        return basic val [type_] [emit [IRFloatDivisionInstruction [
            new register [type_], [Str] [], [a].get, [b].get
        ]]];
    };
}

Val#[Val:a] % [Val:b] {
    Type_:type_ = assert type_ equality [a], [b];
    if ([type_].is_unsigned_int) {
        return basic val [type_] [emit [IRUnsignedModuloInstruction [
            new register [type_], [Str] [], [a].get, [b].get
        ]]];
    } elif ([type_].is_signed_int) {
        return basic val [type_] [emit [IRSignedModuloInstruction [
            new register [type_], [Str] [], [a].get, [b].get
        ]]];
    } else {
        return basic val [type_] [emit [IRFloatModuloInstruction [
            new register [type_], [Str] [], [a].get, [b].get
        ]]];
    };
}

Val#negate [Val:v] {
    if ([v.type_].is_int) {
        return basic val [v.type_] [emit [IRSubtractionInstruction [
            new register [v.type_], [Str] [], make const [0] [(W)v.type_.bits], [v].get
        ]]];
    } else {
        return basic val [v.type_] [emit [fneg [[v].get]]];
    };
}

Val#[Val:a] eq [Val:b] {
    return do_Val_cmp[a]["eq"][b];
}

Val#[Val:a] gt [Val:b] {
    return do_Val_cmp[a]["gt"][b];
}

Val#[Val:a] ge [Val:b] {
    return do_Val_cmp[a]["ge"][b];
}

Val#[Val:a] lt [Val:b] {
    return do_Val_cmp[a]["lt"][b];
}

Val#[Val:a] le [Val:b] {
    return do_Val_cmp[a]["le"][b];
}

Val#[Val:a] ne [Val:b] {
    return do_Val_cmp[a]["ne"][b];
}

Val#is_NaN[Val:a] {
    IRValue:a_ir = [a].get;
    return basic val [Bool_] [emit [compare float [a_ir] ["uno"] [a_ir]]];
}

Val#[Val:a] shift left [Val:b] {
    if (![a.type_].is_int || ![b.type_].is_int) {
        abort ["Bitshift operations require both types to be an int"];
    };
    if (a.type_.bits != b.type_.bits) {
        abort ["Both operands in a bitshift must have the same number of bits"];
    };

    return basic val [a.type_] [emit [IRLeftShiftInstruction [
        new register [a.type_], [Str] [], [a].get, [b].get
    ]]];
}

Val#[Val:a] shift right [Val:b] {
    if (![a.type_].is_int || ![b.type_].is_int) {
        abort ["Bitshift operations require both types to be an int"];
    };
    if (a.type_.bits != b.type_.bits) {
        abort ["Both operands in a bitshift must have the same number of bits"];
    };

    if ([a.type_].is_signed_int) {
        return basic val [a.type_] [emit [IRSignedRightShiftInstruction [
            new register [a.type_], [Str] [], [a].get, [b].get
        ]]];
    } else {
        return basic val [a.type_] [emit [IRUnsignedRightShiftInstruction [
            new register [a.type_], [Str] [], [a].get, [b].get
        ]]];
    };
}

Val#&[Val:v] {
    return basic val [Pointer [v.type_]] [[v.assignable].unwrap.addr];
}

Val#*[Val:val] {
    if ([val.type_.name] not equals ["#Pointer"]) {
        abort ["Can only directly dereference Pointer type_, not {}" % [val.type_].stringify];
    };
    return assignable val [val.type_.generics[0]] [[val].get];
}

Val#*[Type_:type_][Val:val] {
    return assignable val [type_] [[val].get];
}

Val#load [Val:val] {
    return basic val [val.type_] [[val].get];
}

#[Val:assignable] = [Val:val] {
    if (![val.type_] == [assignable.type_]) {
        abort ["Cannot assign value of type_ {} to assignable of type_ {}" % [val.type_].stringify % [assignable.type_].stringify];
    };

    if (assignable.assignable) {
        emit [store [[val].get] in [[assignable.assignable].unwrap.addr]];
    } else {
        abort ["Expected assignable"];
    };
}

Val#var [Type_:type_] {
    return assignable val [type_] [emit [alloca [[type_].ir]]];
}

Val#var [Type_:type_] [Val:init] {
    Val:var = var [type_];
    [var] = [init];
    return var;
}

Val#var [Val:init] {
    return var [init.type_] [init];
}

ExternFunc#get fn [Str:name] {
    ExternFunc?:fn = get func named [name];
    if ([fn].is_null) {
        abort ["Cannot find function with requested name {}" % name];
    };
    return [fn].unwrap;
}

#private accessibility {
    add func specifier ["private"];
}

#add func specifier [Str:specifier] {
    Str:to_add = " {}" % specifier;
    given (get state.next_fn_specifiers as Str:next_fn_specifiers) {
        [next_fn_specifiers].extend[to_add];
    } else {
        get state.next_fn_specifiers = to_add;
    };
}

#add func attrs [[Str]:attrs] {
    [Str]:fn_attrs = [Str] [];
    given (get state.next_fn_attrs as [Str]:next_fn_attrs) {
        fn_attrs = next_fn_attrs;
    } else {
        get state.next_fn_attrs = fn_attrs;
    };
    [fn_attrs].extend[attrs];
}

#extern fn [Type_:ret_type_] [Str:name] [[Type_]:arg_types_] {
    require extern fn [ret_type_] [name] [arg_types_] [false];
}

#extern fn [Type_:ret_type_] [Str:name] [[Type_]:arg_types_] vargs {
    require extern fn [ret_type_] [name] [arg_types_] [true];
}

#call [ExternFunc:func] [[Val]:args] {
    call [func.ret_type_] [register of func [func.ir_func]] [func.args] [args];
}

#call [Val:func] [[Val]:args] {
    assert [func] is callable;
    [Type_]:arg_types_ = [func.type_.generics].clone;
    Type_:ret_type_ = [arg_types_].pop[0];
    IRRegister?:maybe_register = [func].get.register;
    if ([maybe_register].is_null) {
        abort ["Can't call a constant as a a function pointer"];
    };
    call [ret_type_] [[maybe_register].unwrap] [arg_types_] [args];
}

#extern fn [Type_:ret_type_] [Str:name] [[Type_]:arg_types_] [[Val]:provided_args] {
    if ([arg_types_].len != [provided_args].len) {
        abort ["The number of arguments and the number of argument types_ must match (got {} and {} for {})"
            % [provided_args].len % [arg_types_].len % name];
    };
    ExternFunc:func = require extern fn [ret_type_] [name] [arg_types_] [false];
    call [func] [provided_args];
}

#extern fn [Type_:ret_type_] [Str:name] [[Type_]:arg_types_] vargs [[Val]:provided_args] {
    ExternFunc:func = require extern fn [ret_type_] [name] [arg_types_] [true];
    call [func] [provided_args];
}

Bool#fn [Type_:ret_type_] [Str:name] [[Type_]:arg_types_] {
    Str:specifiers = next fn specifiers;
    [Str]:fn_attrs = next fn attrs;
    Func_?:defined_fn = defined fn [ret_type_] [name] [arg_types_];
    if (defined_fn) {
        get state.last_defined_func = [defined_fn].unwrap.base;
        return false;
    } else {
        Func_:new_fn = new fn [ret_type_] [name] [arg_types_] specifiers: [specifiers] fn_attrs: [fn_attrs];
        get state.last_defined_func = new_fn.base;
        add fn [new_fn];
        return true;
    };
}

Bool#fn [Type_:ret_type_] [Str:name] [[Type_]:arg_types_] [[Val]:provided_args] {
    if ([arg_types_].len != [provided_args].len) {
        abort ["The number of arguments and the number of argument types_ must match (got {} and {} for {})"
            % [provided_args].len % [arg_types_].len % name];
    };
    Str:specifiers = next fn specifiers;
    [Str]:fn_attrs = next fn attrs;
    Func_?:defined_fn = defined fn [ret_type_] [name] [arg_types_];
    if (defined_fn) {
        call [[defined_fn].unwrap.base] [provided_args];
        get state.last_defined_func = [defined_fn].unwrap.base;
        return false;
    } else {
        Func_:new_fn = new fn [ret_type_] [name] [arg_types_] specifiers: [specifiers] fn_attrs: [fn_attrs];
        call [new_fn.base] [provided_args];
        get state.last_defined_func = new_fn.base;
        add fn [new_fn];
        return true;
    };
}

Bool#specialized fn [Type_:ret_type_] [Str:name] [[Val]:args] {
    [Type_]:arg_types_ = [Type_] [];
    for (Val:arg in args) {
        [arg_types_].append[arg.type_];
    };
    Str:full_name = [name].clone;
    for (Type_:arg_type_ in arg_types_) {
        [full_name].append['_'];
        [full_name].extend[[arg_type_].stringify];
    };
    private accessibility;
    return fn [ret_type_] [full_name] [arg_types_] [args];
}

Bool#specialized fn [Type_:ret_type_] [Str:name] [[Type_]:arg_types_] {
    Str:full_name = [name].clone;
    for (Type_:arg_type_ in arg_types_) {
        [full_name].append['_'];
        [full_name].extend[[arg_type_].stringify];
    };
    private accessibility;
    return fn [ret_type_] [full_name] [arg_types_];
}

#ret void {
    emit [ret void instruction];
}

#ret [Val:val] {
    if ([val.type_.name] equals ["Null"]) {
        ret void;
    } else {
        emit [ret [[val].get]];
    };
}

#mark as unreachable {
    emit [unreachable instruction];
}

#end fn {
    require basic block termination;
    [Func_]:func_stack = get state.func_stack;
    [func_stack].pop_end;
}

Val#func ret {
    Val?:ret = get active func.last_ret_val;
    if ([ret].is_null) {
        abort ["The current function has not called another function"];
    };
    return [ret].unwrap;
}

Type_#[ExternFunc:func].ptr_type_ {
    if (func.ir_func.has_vargs) {
        abort ["Pointers to functions with vargs currently can't be represented in the EEWriter type_ system"];
    };
    return FuncPtr [func.ret_type_] [func.args];
}

Val#func ptr {
    ExternFunc?:func = get state.last_defined_func;
    if ([func].is_null) {
        abort ["A function must be defined or required before a function pointer can be created"];
    };
    return [[func].unwrap].func_ptr;
}

Val#[ExternFunc:func].func_ptr {
    return const val [[func].ptr_type_] [[func.ir_func].make_ptr];
}

Val#func arg [L:i] {
    Type_:type_ = get active func.base.args[i];
    return basic val [type_] [make_val [IRRegister [false, "arg{}" % i, [type_].ir]]];
}

Val#alloca [Val:count] [Type_:type_] {
    return assignable val [type_] [emit [alloca [[count].get] [[type_].ir]]];
}

Block#current block {
    [Block]:block_stack = get active func.block_stack;
    return [block_stack].at[-1];
}

Bool#is block terminated {
    return current bb.is_terminated;
}

#break_ [Block:block] {
    emit [branch to [block.otherwise]];
}

#continue_ [Block:block] {
    emit [branch to [block.entry]];
}

#end block {
    Block:block = pop from block stack;
    emit [branch to [block.end]] unless terminated;
    set current bb [block.otherwise];
}

Label#new label {
    return Label [new bb];
}

#[Label:label]: {
    emit [branch to [label.block]] unless terminated;
    set current bb [label.block];
}

Label#new label: {
    IRBasicBlock:bb = new bb;
    emit [branch to [bb]] unless terminated;
    set current bb [bb];
    return Label [bb];
}

#goto_ [Label:label] {
    emit [branch to [label.block]] unless terminated;
}

#goto_ [Val:cond] ? [Label:if_true] : [Label:if_false] {
    IRValue:cond_bool = compute truth value [cond.type_] [[cond].get];
    emit [branch to [if_true.block] if_ [cond_bool] else_ [if_false.block]] unless terminated;
}

#switch_ on [Val:val] to [[Val]:targets] [[Label]:labels] otherwise [Label:otherwise] {
    [$IRConstant]:const_targets = [$IRConstant] [];
    for (Val:target in targets) {
        [const_targets].append[get_const_from_val[target]];
    };
    [IRBasicBlock]:blocks = [IRBasicBlock] [];
    for (Label:label in labels) {
        [blocks].append[label.block];
    };
    emit [switch_ on [[val].get] to [const_targets] [blocks] otherwise [otherwise.block]];
}

#if_ [Val:cond] {
    IRBasicBlock:entry = new bb;
    IRBasicBlock:otherwise = new bb;
    IRValue:cond_bool = compute truth value [cond.type_] [[cond].get];
    emit [branch to [entry] if_ [cond_bool] else_ [otherwise]];
    add block [Block [entry, otherwise, otherwise]] to stack;
    set current bb [entry];
}

#else_ {
    IRBasicBlock:otherwise = pop from block stack.otherwise;
    IRBasicBlock:end = new bb;
    add block [Block [otherwise, end, end]] to stack;
    emit [branch to [end]] unless terminated;
    set current bb [otherwise];
}

#while_ [Val:cond] from [Label:label] {
    IRBasicBlock:entry = label.block;
    IRBasicBlock:body = new bb;
    IRBasicBlock:otherwise = new bb;
    IRValue:cond_bool = compute truth value [cond.type_] [[cond].get];
    emit [branch to [body] if_ [cond_bool] else_ [otherwise]];
    add block [Block [entry, otherwise, entry]] to stack;
    set current bb [body];
}

#start block [Block:block] {
    require basic block termination;
    add block [block] to stack;
    set current bb [block.entry];
}

Block#create block with entry [Label:entry], otherwise [Label:otherwise], ending with [Label:end] {
    return Block [entry.block, otherwise.block, end.block];
}

PHINode#new PHI [Type_:type_] {
    return PHINode [type_, IRPHIInstruction [new register [[type_].ir], [IRValue] [], [W] []]];
}

#[PHINode:phi].add_incoming[Val:val] {
    if (![val.type_] == [phi.type_]) {
        abort ["Incorrect type_ for PHI operand: expected {}, found {}" % [phi.type_].stringify % [val.type_].stringify];
    };
    val = load [val];
    if (val.basic) {
        BasicVal:basic = [val.basic].unwrap;
        [phi.ir.vals].append[basic.val];
        [phi.ir.block_ids].append[basic.bb.id];
    } else {
        abort ["Expected BasicVal"];
    };
}

Val#[PHINode:phi].place_here {
    emit [phi.ir];
    return [phi].val;
}

Val#[PHINode:phi].val {
    return basic val [phi.type_] [make_val [phi.ir]];
}

// always evaluates both operands
Val#[Val:cond] ? [Val:if_true] : [Val:if_false] {
    assert type_ equality [if_true], [if_false];
    IRValue:ir_cond = compute truth value [cond.type_] [[cond].get];
    return basic val [if_true.type_] [emit [
        select [[if_true.type_].ir] [[if_true].get] if_ [ir_cond] else_ [[if_false].get]
    ]];
}

Val#[Val:ptr] shifted by [Val:offset] {
    $IRType:pointee = [ptr.type_].pointee;
    $IRValuedInstruction:GEP = GEP [pointee] [[ptr].get] [[IRValue] [[offset].get]];
    return basic val [ptr.type_] [emit [GEP]];
}

Val#sizeof [Type_:type_] {
    IRValue:ptr = [[c null_ [Pointer [type_]]] shifted by [c L_[1]]].get;
    return basic val [L_] [emit [ptr [ptr] to int [IRIntType [64]]]];
}

Val#sizeof pointee [Type_:type_] {
    IRValue:ptr = [[c null_ [type_]] shifted by [c L_[1]]].get;
    return basic val [L_] [emit [ptr [ptr] to int [IRIntType [64]]]];
}

Val#sizeof elem [Type_:type_] {
    assert [type_] is array;
    return sizeof [type_.generics[0]];
}

Val#malloc [Val:bytes] {
    add func attrs [[Str] ["mustprogress", "nofree", "allockind(\"alloc,uninitialized\")", "allocsize(0)"]];
    extern fn [Internal_] ["epsl_malloc"] [[Type_] [L_]]
        [[Val] [cast [bytes] to [L_]]];
    return func ret;
}

Val#malloc [Type_:type_] {
    return cast [malloc [sizeof [type_]]] to [Pointer [type_]];
}

Val#malloc [Val:count] [Type_:type_] {
    Val:bytes = [sizeof [type_]] * [cast [count] to [L_]] bound: [false];
    return cast [malloc [bytes]] to [Pointer [type_]];
}

Val#malloc pointee [Type_:type_] {
    return cast [malloc [sizeof pointee [type_]]] to [type_];
}

Val#malloc pointee [Val:count] [Type_:type_] {
    Val:bytes = [sizeof pointee [type_]] * [cast [count] to [L_]] bound: [false];
    return cast [malloc [bytes]] to [type_];
}

Val#realloc [Val:val] to [Val:bytes] bytes {
    add func attrs [[Str] ["mustprogress", "allockind(\"realloc\")", "allocsize(1)"]];
    extern fn [Internal_] ["epsl_realloc"] [[Type_] [Internal_, L_]]
        [[Val] [val, cast [bytes] to [L_]]];
    return func ret;
}

Val#realloc [Val:val] to [Val:count] elements {
    assert [val] is pointer;
    Val:bytes = [sizeof pointee [val.type_]] * [cast [count] to [L_]] bound: [false];
    return cast [realloc [cast [val] to [Internal_]] to [bytes] bytes] to [val.type_];
}

#free [Val:val] {
    extern fn [Null_] ["free"] [[Type_] [Internal_]] [[Val] [cast [val] to [Internal_]]];
}

#memcpy [Val:count] [Val:v1] to [Val:v2] {
    extern fn [Null_] ["llvm.memcpy.p0.p0.i64"] 
        [[Type_] [Internal_, Internal_, L_, Bool_]] 
        [[Val] [
            cast [v2] to [Internal_], cast [v1] to [Internal_],
            [sizeof pointee [v1.type_]] * [cast [count] to [L_]] bound: [false],
            c [false] // not volatile
        ]];
}

#memcpy [Val:v1] to [Val:v2] {
    memcpy [c L_ [1]] [v1] to [v2];
}

#memmove [Val:count] [Val:v1] to [Val:v2] {
    extern fn [Null_] ["llvm.memmove.p0.p0.i64"] 
        [[Type_] [Internal_, Internal_, L_, Bool_]] 
        [[Val] [
            cast [v2] to [Internal_], cast [v1] to [Internal_],
            [sizeof pointee [v1.type_]] * [cast [count] to [L_]] bound: [false],
            c [false] // not volatile
        ]];
}

#memset [Val:count] bytes of [Val:buffer] to [Val:ch] {
    extern fn [Null_] ["llvm.memset.p0.i64"]
        [[Type_] [Internal_, Byte_, L_, Bool_]]
        [[Val] [
            cast [buffer] to [Internal_], cast [ch] to [Byte_],
            cast [count] to [L_], c [false] // not volatile
        ]];
}

#assume [Val:val] {
    if (![val.type_] == [Bool_]) {
        abort ["Can only assume that a boolean is true, not a {}" % [val.type_].stringify];
    };
    extern fn [Null_] ["llvm.assume"] [[Type_] [Bool_]] [[Val] [val]];
}

// returns the val with the expectation attached
Val#expect [Val:val] to be [Bool:truth_value] {
    if (![val.type_] == [Bool_]) {
        abort ["Can only provide an expectation of a boolean's value, found a {}" % [val.type_].stringify];
    };
    extern fn [Bool_] ["llvm.expect.i1"] [[Type_] [Bool_, Bool_]] [[Val] [val, c [truth_value]]];
    return func ret;
}

Val#[Val:poly].struct_ {
    assert [poly] is poly;
    Type_:dest_type_ = StructBase;
    if ([poly.type_.name] equals ["Poly"]) {
        dest_type_ = poly.type_.generics[0];
    };
    return extract field [0] of [poly] as [dest_type_];
}

Val#[Val:poly].vtable {
    assert [poly] is poly;
    return extract field [1] of [poly]
        as [Pointer [VTable [poly.type_]]];
}

Val#[Val:vtable].vtable_item[W:i] {
    assert [vtable] is pointer;
    assert [vtable.type_.generics[0]] is vtable;
    Type_:type_ = [Type_] [
        L_, // the struct id number
        L_, // the length of the extendee list
        Pointer [L_], // the extendee list
        Str_, // the struct id (as a Str_)
        FuncPtr [Null_] [[Type_] [Internal_]] // the free fn
    ][i];
    return load [*[access field [i] of [vtable] as [type_]]];
}

Val#does [Val:poly] extend [Struct_:struct] {
    Val:vtable = [poly].vtable;
    L:expected_index = [struct.extendee_ids].len - 1;
    Val:extendee_count = [vtable].vtable_item[1];
    PHINode:result_phi = new PHI [Bool_];
    [result_phi].add_incoming [c [false]];
    if_ [[c L_ [expected_index]] lt [extendee_count]];
        Val:extendee_list = [vtable].vtable_item[2];
        Val:idx_val = *[[extendee_list] shifted by [c L_ [expected_index]]];
        Val:struct_id_val = c L_ [struct.id_num];
        [result_phi].add_incoming[[idx_val] eq [struct_id_val]];
    end block;
    return [result_phi].place_here;
}

Val#[Val:arr].capacity {
    assert [arr] is array;
    return *[access field [1] of [arr] as [L_]];
}

Val#[Val:arr].length {
    assert [arr] is array;
    return *[access field [2] of [arr] as [L_]];
}

Val#[Val:arr].content {
    assert [arr] is array;
    return *[access field [3] of [arr] as [Pointer [arr.type_.generics[0]]]];
}

Val#[Val:val].idx[Val:idx] {
    if ([val.type_.name] equals ["Array"]) {
        return [[val].content].idx[idx];
    } elif ([val.type_.name] equals ["#Pointer"]) {
        return *[[val] shifted by [idx]];
    } else {
        abort ["Cannot index into value of type_ {}" % [val.type_].stringify];
    };
}

Val#[Val:val].[W:field] {
    Struct_:struct_ = assert [val] is struct_;
    Type_:field_type_ = struct_.fields[field].type_;
    if (struct_.is_ref) {
        // +1 because of the ref_counter field
        return *[access field [field+1] of [val] as [field_type_]];
    } else {
        return basic val [field_type_] [emit [
            extract value [[val].get] [[W] [field]] [[field_type_].ir]
        ]];
    };
}

Val#[Val:val].[Str:field] {
    Struct_:struct_ = assert [val] is struct_;
    L:field_idx = index of field [field] in [struct_];
    return [val].[(W)field_idx];
}

/*
these functions do not work

Val#get field [Str:field] of [Val:val] {
    Struct_:struct_ = assert [val] is nonref struct_;
    L:field_idx = index of field [field] in [struct_];
    Type_:field_type_ = struct_.fields[field_idx].type_;
    return basic val [field_type_] [emit [
        extract value [[val].get] [[W] [field_idx]] [[field_type_].ir]
    ]];
}

Val#with field [Str:field] of [Val:val] as [Val:new_] {
    Struct_:struct_ = assert [val] is nonref struct_;
    L:field_idx = index of field [field] in [struct_];
    Type_:field_type_ = struct_.fields[field_idx].type_;
    if (![new_.type_] == [field_type_]) {
        abort ["Field {} has type_ {}, cannot insert value of type_ {}" % field % [field_type_].stringify % [new_.type_].stringify];
    };
    return basic val [field_type_] [emit [
        insert value [[new_].get] [[val].get] [[W] [field_idx]]
    ]];
}
*/

Val#make global [Type_:type_] [Str?:name] [Val?:maybe_init] {
    $IRConstant?:const_init = null;
    given (maybe_init as Val:init) {
        const_init = get_const_from_val[init];
    };
    IRValue:ir_ptr = make_global type: [[type_].ir] name: [name]
        basic_init: [const_init] str_init: [null] is_extern: [false] is_const: [false];
    return assignable val [type_] [ir_ptr];
}

Val#make ptr to global [Type_:type_] [Str?:name] [Val?:init] {
    $IRConstant?:const_init = null;
    if (init) {
        const_init = get_const_from_val[[init].unwrap];
    };
    IRValue:ir_ptr = make_global type: [[type_].ir] name: [name]
        basic_init: [const_init] str_init: [null] is_extern: [false] is_const: [false];
    return const val [Pointer [type_]] [ir_ptr];
}

Val#make global struct_ [Type_:type_] [Str?:name] [[Val]:elements] {
    [$IRConstant]:const_elements = [$IRConstant] [];
    for (Val:element in elements) {
        [const_elements].append[get_const_from_val[element]];
    };
    $IRType:pointee = [type_].pointee;
    $IRConstant:const_init = [make const [pointee] [const_elements].constant].unwrap;
    IRValue:ir_ptr = make_global type: [pointee] name: [name]
        basic_init: [const_init] str_init: [null] is_extern: [false] is_const: [false];
    return const val [type_] [ir_ptr];
}

Val#extern global [Type_:type_] [Str:name] {
    return assignable val [type_] [
        make_global type: [[type_].ir] name: [name] basic_init: [null]
            str_init: [null] is_extern: [true] is_const: [false]
    ];
}

Val#make const [Type_:type_] [Str?:name] [Val:init] {
    return assignable val [type_] [
        make_global type: [[type_].ir] name: [name]
            basic_init: [get_const_from_val[init]] str_init: [null]
            is_extern: [false] is_const: [true]
    ];
}

Val#extern const [Type_:type_] [Str:name] {
    return assignable val [type_] [
        make_global type: [[type_].ir] name: [name] basic_init: [null]
            str_init: [null] is_extern: [true] is_const: [true]
    ];
}

Val#const str [Str:str] {
    $IRType:type = IRArrayType [[str].len, IRIntType [8]];
    return const val [Pointer [Byte_]] [
        make_global type: [type] name: [null] basic_init: [null] str_init: [str]
            is_extern: [false] is_const: [true]
    ];
}

Val#global mut str [Str:str] {
    $IRType:type = IRArrayType [[str].len, IRIntType [8]];
    return const val [Pointer [Byte_]] [
        make_global type: [type] name: [null] basic_init: [null] str_init: [str]
            is_extern: [false] is_const: [false]
    ];
}

Val#mut str [Str:str] with [W:extra_cap] extra capacity {
    Val:result = malloc [c L_ [[str].len + extra_cap]] [Byte_];
    memcpy [c L_ [[str].len]] [const str [str]] to [result];
    return result;
}

Val#mut str [Str:str] {
    return mut str [str] with [0] extra capacity;
}

Val#make global Str_ [Str:string] {
    Val:str_mem = global mut str [string];
    [Val]:elements = [Val] [c L_ [1], c L_ [0], c L_ [[string].len], str_mem];
    return make global struct_ [Str_] [null] [elements];
}

#add error frame [Str:frame_str] {
    // *++epsl_error_stack_top = frame;
    Val:error_stack_top = get error stack top;
    Val:new_top = [error_stack_top] shifted by [c L_ [1]];
    [*[new_top]] = [const str [[frame_str] + ["\0"]]];
    [error_stack_top] = [new_top];
}

#remove error frame {
    Val:error_stack_top = get error stack top;
    Val:new_top = [error_stack_top] shifted by [c [-1]];
    [error_stack_top] = [new_top];
}

Val#new array [Type_:type_] [[Val]:vals] with capacity [L:capacity] {
    if ([type_.name] not equals ["Array"]) {
        abort ["Expected Array type_, found {}" % [type_].stringify];
    };

    Val:result = malloc pointee [type_];
    [result].init_ref;

    if (capacity < [vals].len) {
        capacity = [vals].len;
    };
    if (capacity < 0) {
        capacity = 1;
    };
    [[result].capacity] = [c L_ [capacity]];

    [[result].length] = [c L_ [[vals].len]];

    Val:content = malloc [c L_ [capacity]] [type_.generics[0]];
    for (L:i enumerating vals) {
        Val:val = load [vals[i]];
        [val].incr_ref;
        [[content].idx[c L_ [i]]] = [val];
    };
    [[result].content] = [content];

    return result;
}

Val#new array [Type_:type_] [[Val]:vals] {
    return new array [type_] [vals] with capacity [0];
}

Val#new struct_ [Type_:type_] [[Val]:fields] {
    Struct_:struct_ = assert [type_] is struct_;
    if (struct_.is_ref) {
        return new ref struct_ [struct_] [fields];
    } else {
        return new nonref struct_ [struct_] [fields];
    };
}

Val#new ref struct_ [Struct_:struct_] [[Val]:fields] {
    Val:result = malloc pointee [T_ [struct_.id]];
    [result].init_ref;

    for (W:i enumerating fields) {
        Val:field_val = fields[i];
        Field:struct_field = struct_.fields[i];
        if (![field_val.type_] == [struct_field.type_]) {
            abort ["Expected value of type_ {} for field {}, found value of type_ {}" % [struct_field.type_].stringify % struct_field.name % [field_val.type_].stringify];
        };
        [[result].[i]] = [field_val];
    };

    return result;
}

Val#new nonref struct_ [Struct_:struct_] [[Val]:fields] {
    [IRValue]:fields_ir = [IRValue] [];
    for (Val:field in fields) {
        [fields_ir].append[[field].get];
    };
    return basic val [T_ [struct_.id]] [make nonref struct_ [fields_ir]];
}

#printf [Str:template] [[Val]:vals] {
    extern fn [Z_] ["epsl_printf"] [[Type_] [Pointer [Byte_]]] vargs
        [[[Val] [const str [template]]] + [vals]];
}

Val#[Val:val] == null_ {
    return basic val [Bool_] [[val.type_] [[val].get] == null_];
}

Val#[Val:val] != null_ {
    return basic val [Bool_] [[val.type_] [[val].get] != null_];
}

Val#deep [Val:val] == null_ {
    return deep [val] == null_ invert: [false];
}

Val#deep [Val:val] != null_ {
    return deep [val] == null_ invert: [true];
}

[Val]#[Val:val].all_components {
    given [val.type_].get_struct as Struct_:struct_ {
        Struct_:struct_ = assert [val] is struct_;
        [Val]:fields = [Val] [];
        for (W:i enumerating struct_.fields) {
            [fields].append[load [[val].[i]]];
        };
        return fields;
    } else {
        return [Val] [];
    };
}

Val#[Val:val].ref {
    assert [val] is nonnullable;
    assert [val] is ref;
    if ([val.type_].is_poly) {
        return [[val].struct_].ref;
    } else {
        return *[bitcast [val] to [Pointer [L_]]];
    };
}

#[Val:val].init_ref {
    [[val].ref] = [c L_ [0]];
}

#[Val:val].incr_ref {
    if (![val.type_].is_ref) {
        for (Val:field in [val].all_components) {
            [field].incr_ref;
        };
        return;
    };
    val = load [val];
    Bool:is_nullable = [val.type_].is_nullable;
    if (is_nullable) {
        if_ [deep [val] != null_];
    };
    val = deep unwrap nullability [val];
    Val:rc = [val].ref;
    [rc] = [[rc] + [c L_ [1]] bound: [true]];
    if (is_nullable) {
        end block;
    };
}

#[Val:val].checkless_decr_ref {
    if (![val.type_].is_ref) {
        for (Val:field in [val].all_components) {
            [field].checkless_decr_ref;
        };
        return;
    };
    val = load [val];
    Bool:is_nullable = [val.type_].is_nullable;
    if (is_nullable) {
        if_ [deep [val] != null_];
    };
    val = deep unwrap nullability [val];
    Val:rc = [val].ref;
    [rc] = [[rc] - [c L_ [1]] bound: [true]];
    if (is_nullable) {
        end block;
    };
}

#[Val:val].decr_ref {
    if (![val.type_].is_ref) {
        for (Val:field in [val].all_components) {
            [field].decr_ref;
        };
        return;
    };
    val = load [val];
    Bool:is_nullable = [val.type_].is_nullable;
    if (is_nullable) {
        if_ [deep [val] != null_];
    };
    val = deep unwrap nullability [val];
    Val:rc = [val].ref;
    Val:new_rc = [rc] - [c L_ [1]] bound: [true];
    [rc] = [new_rc];
    [val]._nonnull_check_ref[new_rc];
    if (is_nullable) {
        end block;
    };
}

#[Val:val].check_ref {
    if (![val.type_].is_ref) {
        for (Val:field in [val].all_components) {
            [field].check_ref;
        };
        return;
    };
    val = load [val];
    Bool:is_nullable = [val.type_].is_nullable;
    if (is_nullable) {
        if_ [deep [val] != null_];
    };
    val = deep unwrap nullability [val];
    Val:rc = [val].ref;
    [val]._nonnull_check_ref[rc];
    if (is_nullable) {
        end block;
    };
}

#generate free fn for_ [Struct_:struct_] private: [Bool:is_private] {
    Type_:type_ = T_ [struct_.id];
    if (is_private) {
        private accessibility;
    };
if (fn [Null_] [get free fn symbol for_ [struct_]] [[Type_] [type_]]) {
    Val:val = func arg [0];
    given (struct_.destructor as Str:destructor_symbol) {
        extern fn [Null_] [destructor_symbol] [[Type_] [type_]] [[Val] [val]];
    };
    for (W:i enumerating struct_.fields) {
        if ([struct_.fields[i].type_].is_ref) {
            [load [[val].[i]]].decr_ref;
        };
    };
    free [val];
    ret void;
end fn;
};
}

#generate vtable for_ [Struct_:struct_] {
    Type_:struct_type_ = T_ [struct_.id];

    [L]:extendee_ids = struct_.extendee_ids;
    [$IRConstant]:extendee_id_consts = [$IRConstant] [];
    for (L:extendee_id in extendee_ids step -1) {
        [extendee_id_consts].append[get_const_from_val[c L_ [extendee_id]]];
    };
    $IRType:extendees_ir_type = IRArrayType [[extendee_ids].len, IRIntType [64]];
    IRValue:extendees_val = make const [extendees_ir_type] [extendee_id_consts];
    IRValue:extendee_list = make_global type: [extendees_ir_type] name: [null]
        basic_init: [[extendees_val.constant].unwrap] str_init: [null]
        is_extern: [false] is_const: [true];

    Val:struct_id_str = make global Str_ [struct_.id];

    Str:free_symbol = get free fn symbol for_ [struct_];
    extern fn [Null_] [free_symbol] [[Type_] [struct_type_]];
    Val:free_fn_ptr = func ptr;

    Type_:vtable_type_ = VTable [Poly_ [struct_type_]];
    IRValue:vtable_val = make const nonref struct_ [[IRValue] [
        make const [struct_.id_num] [64],
        make const [[extendee_ids].len] [64],
        extendee_list,
        [struct_id_str].get,
        [free_fn_ptr].get
    ]];

    make const [vtable_type_] [get vtable symbol for_ [struct_]]
        [const val [vtable_type_] [vtable_val]];
}

Val#vtable for_ [Type_:type_] {
    Struct_:struct_ = assert [type_] is struct_;
    return extern const [VTable [Poly_ [type_]]] [get vtable symbol for_ [struct_]];
}
